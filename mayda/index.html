<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `mayda` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, mayda">

    <title>mayda - Rust</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'></p><script>window.sidebarCurrent = {name: 'mayda', ty: 'mod', relpath: '../'};</script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>mayda</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-0' class='srclink' href='../src/mayda/src/lib.rs.html#8-162' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p><code>mayda</code> is a library to compress integer arrays (all primitive integer
types are supported). The design favors decompression speed and the ability
to index the compressed array over the compression ratio, on the principle
that the runtime penalty for using compressed arrays should be as small as
possible.</p>

<p>This crate provides three variations on a single compression algorithm. The
<code>Uniform</code> type can decompress around six billion <code>u32</code>s per second, or 24
GiB/s of decompressed integers, on a 2.6 GHz Intel Core i7-6700HQ processor
(see below for specifics). The <code>Monotone</code> and <code>Unimodal</code> types decompress
at a little less than half the speed, but can have much better compression
ratios depending on the distribution of the integers. Overall performance is
comparable to the fastest (known) libraries in any language.</p>

<h1 id='usage' class='section-header'><a href='#usage'>Usage</a></h1>
<p>Add this to your <code>Cargo.toml</code>:</p>

<pre><code class="language-toml">[dependencies]
mayda = &quot;^0.2&quot;
</code></pre>

<p>and this to your crate root:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>mayda</span>;</pre>

<h1 id='example-encoding-and-decoding' class='section-header'><a href='#example-encoding-and-decoding'>Example: encoding and decoding</a></h1>
<p>The <code>Uniform</code> struct is recommended for general purpose integer compression.
Use the <code>Encode</code> trait to encode and decode the array.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>mem</span>;
<span class='kw'>use</span> <span class='ident'>mayda</span>::{<span class='ident'>Uniform</span>, <span class='ident'>Encode</span>};
 
<span class='comment'>// Integers in some interval of length 255, require one byte per integer</span>
<span class='kw'>let</span> <span class='ident'>input</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> <span class='op'>=</span> (<span class='number'>0</span>..<span class='number'>128</span>).<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> (<span class='ident'>x</span> <span class='op'>*</span> <span class='number'>73</span>) <span class='op'>%</span> <span class='number'>181</span> <span class='op'>+</span> <span class='number'>307</span>).<span class='ident'>collect</span>();
 
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>uniform</span> <span class='op'>=</span> <span class='ident'>Uniform</span>::<span class='ident'>new</span>();
<span class='ident'>uniform</span>.<span class='ident'>encode</span>(<span class='kw-2'>&amp;</span><span class='ident'>input</span>).<span class='ident'>unwrap</span>();
 
<span class='kw'>let</span> <span class='ident'>i_bytes</span> <span class='op'>=</span> <span class='ident'>std</span>::<span class='ident'>mem</span>::<span class='ident'>size_of_val</span>(<span class='ident'>input</span>.<span class='ident'>as_slice</span>());
<span class='kw'>let</span> <span class='ident'>u_bytes</span> <span class='op'>=</span> <span class='ident'>std</span>::<span class='ident'>mem</span>::<span class='ident'>size_of_val</span>(<span class='ident'>uniform</span>.<span class='ident'>storage</span>());
 
<span class='comment'>// 128 bytes for encoded entries, 12 bytes of overhead</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>i_bytes</span>, <span class='number'>512</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>u_bytes</span>, <span class='number'>140</span>);
 
<span class='kw'>let</span> <span class='ident'>output</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>uniform</span>.<span class='ident'>decode</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>input</span>, <span class='ident'>output</span>);</pre>

<h1 id='example-indexing' class='section-header'><a href='#example-indexing'>Example: indexing</a></h1>
<p>Use the <code>Access</code> or <code>AccessInto</code> traits to index the compressed array. This
is similar to <code>Index</code>, but returns a vector instead of a slice.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>mayda</span>::{<span class='ident'>Uniform</span>, <span class='ident'>Encode</span>, <span class='ident'>Access</span>};
 
<span class='comment'>// All primitive integer types supported</span>
<span class='kw'>let</span> <span class='ident'>input</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i16</span><span class='op'>&gt;</span> <span class='op'>=</span> (<span class='op'>-</span><span class='number'>64</span>..<span class='number'>64</span>).<span class='ident'>collect</span>();
 
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>uniform</span> <span class='op'>=</span> <span class='ident'>Uniform</span>::<span class='ident'>new</span>();
<span class='ident'>uniform</span>.<span class='ident'>encode</span>(<span class='kw-2'>&amp;</span><span class='ident'>input</span>).<span class='ident'>unwrap</span>();
 
<span class='kw'>let</span> <span class='ident'>val</span>: <span class='ident'>i16</span> <span class='op'>=</span> <span class='ident'>uniform</span>.<span class='ident'>access</span>(<span class='number'>64</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>val</span>, <span class='number'>0</span>);
 
<span class='comment'>// Vector is returned to give ownership to the caller</span>
<span class='kw'>let</span> <span class='ident'>range</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i16</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>uniform</span>.<span class='ident'>access</span>(..<span class='number'>10</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>range</span>, (<span class='op'>-</span><span class='number'>64</span>..<span class='op'>-</span><span class='number'>54</span>).<span class='ident'>collect</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;&gt;</span>());</pre>

<h1 id='algorithm' class='section-header'><a href='#algorithm'>Algorithm</a></h1>
<p>The compression algorithm relies on the observation that for many integer
arrays, the probability distribution of a block of 128 entries is not
uniform over all values that can be represented by the integer type. For
example, an array of indices into a second array with 256 entries has
entries that are bounded below by 0 and above by 255. This requires only
eight bits per entry, rather than the 32 or 64 generally set aside for a
usize index. The basic idea of the compression algorithm is to represent
all of the entries in a block with a single minimum necessary bit width.
This allows SIMD operations and manual loop unrolling to avoid branches to
be used to accelerate encoding and decoding.</p>

<p>This approach does not perform well for probability distributions with
outliers though, or for situations where the median value is nonzero. This
crate provides three types that handle this situation by applying different
initial transformations to the input integer array.</p>

<p>The <code>Uniform</code> type targets encoding and decoding speed. The only
transformation is to subtract the minimum value from the entries, with the
result that the compression depends only on the difference between the
largest and smallest entries.</p>

<p>The <code>Monotone</code> type is specifically intended for arrays with monotone
increasing entries. A blocks of entries is transformed into an offset and
an array of differences of successive entries, and the array of differences
is encoded by the approach above. The compression depends only on the 
largest entry in the difference array.</p>

<p>The <code>Unimodal</code> type performs the most extensive transformations and offers
the most robust compression. The median value is subtracted from the
entries, the entries are mapped to the unsigned integers by the zig-zag
encoding, and the most significant bits of any outliers are removed and
stored separately. The result is that the compression effectively depends
only on the standard deviation of the probability distribution of the block
entries.</p>

<h1 id='indexing' class='section-header'><a href='#indexing'>Indexing</a></h1>
<p>Indexing an object of the <code>Uniform</code>, <code>Monotone</code> or <code>Unimodal</code> types is not
a simple pointer offset. Part of the header encodes the relative offsets to
every block in a compressed form, with the result that random access via
the <code>Access</code> trait is an <code>O(log(idx))</code> operation, where <code>idx</code> is the value
of the index (not the length of the array). The overhead of this part of
the header is around a tenth of a bit per encoded integer.</p>

<p>If you need to access several nearby entries, consider accessing the range
and indexing the returned vector for performance.</p>

<h1 id='safety' class='section-header'><a href='#safety'>Safety</a></h1>
<p>As a general rule, you <strong>should not</strong> decode or access objects of the
<code>Uniform</code>, <code>Monotone</code> or <code>Unimodal</code> types from untrusted sources.</p>

<p><code>mayda</code> performs wildly unsafe pointer operations during encoding and
decoding. Changing the header information with <code>mut_storage</code> can cause data
to be written to or read from arbitrary addresses in memory.</p>

<p>That said, the situation is the same for any of the data structures in the
standard library (consider the <code>set_len</code> method of a <code>Vec</code>).</p>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Reexports</a></h2>
<table><tr><td><code>pub use self::<a class='mod'
                                       href='./error/index.html'>error</a>::<a class='struct' href='../mayda/error/struct.Error.html' title='mayda::error::Error'>Error</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                       href='./monotone/index.html'>monotone</a>::<a class='struct' href='../mayda/monotone/struct.Monotone.html' title='mayda::monotone::Monotone'>Monotone</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                       href='./uniform/index.html'>uniform</a>::<a class='struct' href='../mayda/uniform/struct.Uniform.html' title='mayda::uniform::Uniform'>Uniform</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                       href='./unimodal/index.html'>unimodal</a>::<a class='struct' href='../mayda/unimodal/struct.Unimodal.html' title='mayda::unimodal::Unimodal'>Unimodal</a>;</code></td></tr><tr><td><code>pub use self::utility::{<a class='trait' href='../mayda/utility/trait.Access.html' title='mayda::utility::Access'>Access</a>, <a class='trait' href='../mayda/utility/trait.AccessInto.html' title='mayda::utility::AccessInto'>AccessInto</a>, <a class='trait' href='../mayda/utility/trait.Encode.html' title='mayda::utility::Encode'>Encode</a>};</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class='mod' href='error/index.html'
                                  title='mayda::error'>error</a></td>
                           <td class='docblock short'>
                                <p>Defines the <code>mayda::Error</code> type. Currently only used for the return types of
functions defined in the <code>Encode</code> trait, but intended to allow for more
complex error handling in the future.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='mod' href='monotone/index.html'
                                  title='mayda::monotone'>monotone</a></td>
                           <td class='docblock short'>
                                <p><code>Monotone</code> encoding of integer arrays. Intended for cases where the entries
are monotonically increasing. Implemented for all primitive integer types.  </p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='mod' href='uniform/index.html'
                                  title='mayda::uniform'>uniform</a></td>
                           <td class='docblock short'>
                                <p><code>Uniform</code> encoding of integer arrays. Intended for cases where encoding and
decoding speed is desired, or the probability distribution of the entries
is uniform within certain bounds. Implemented for all primitive integer
types.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='mod' href='unimodal/index.html'
                                  title='mayda::unimodal'>unimodal</a></td>
                           <td class='docblock short'>
                                <p><code>Unimodal</code> encoding of integer arrays. Intended for cases where information
about the probability distribution of the entries is not known, and the
presence of outliers reduces the compression ratio of the other types.
Implemented for all primitive integer types.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class='mod' href='utility/index.html'
                                  title='mayda::utility'>utility</a></td>
                           <td class='docblock short'>
                                <p>Contains constants, enums, traits and functions used by all of the encoding
types provided by the <code>mayda</code> crate.</p>
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "mayda";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script defer src="../search-index.js"></script>
</body>
</html>