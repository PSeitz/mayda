// Copyright 2016 Jeremy Mason
//
// Licensed under the MIT license <LICENSE or
// http://opensource.org/licenses/MIT>. This file may not be copied, modified,
// or distributed except according to those terms.

//! Compiler plugin to generate basic encoding and decoding functions. The
//! generated functions follow the convention encode_T_a_b and decode_T_a_b,
//! where T is one of the unsigned integer types, a is the number of bits per
//! integer, and b is the number of integers encoded.
//!
//! The encode! and decode! syntax extensions take as arguments the unsigned
//! integer type, the maximum number of bits per integer (less than or equal to
//! the type width), and a step for the number of integers encoded (a divisor
//! of 32). Functions are generated for numbers of bits in [1...max_bits], and
//! for numbers of integers in multiples of the step up to 32.
//!
//! Pointers to the generated functions are available in ENCODE_T and DECODE_T.
//! These are public constant arrays, with the pointer for encode_T_a_b at 
//! ENCODE_T[a - 1][b / c - 1], where c is the step.
//! 
//! # Safety
//!
//! The functions generated by this crate use wildly unsafe pointer operations.
//! You must verify that enough memory is already allocated after the pointers
//! that the offsets are valid. They are not intended to be used outside the
//! pfor crate.
//! 
//! # Examples
//!
//! The syntax extensions defined in this crate can be invoked as
//!
//! ```
//! encode!(u64, 64, 8);
//! decode!(u64, 64, 8);
//! ```
//!
//! This is replaced by 256 functions that encode u64 integers and 256
//! functions that decode u64 integers. For example, the functions that encode
//! and decode the 48 least significant bits of 8 u64 integers are
//!
//! ```
//! unsafe fn encode_u64_48_8(i_ptr: *const u64, s_ptr: *mut u32) {
//!     let mut i_ptr = i_ptr;
//!     let mut s_ptr = s_ptr;
//!     *s_ptr = (*i_ptr >> 16usize) as u32;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = (*i_ptr as u32) << 16usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= (*i_ptr >> 32usize) as u32;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr as u32;
//!     s_ptr = s_ptr.offset(1);
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr = (*i_ptr >> 16usize) as u32;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = (*i_ptr as u32) << 16usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= (*i_ptr >> 32usize) as u32;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr as u32;
//!     s_ptr = s_ptr.offset(1);
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr = (*i_ptr >> 16usize) as u32;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = (*i_ptr as u32) << 16usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= (*i_ptr >> 32usize) as u32;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr as u32;
//!     s_ptr = s_ptr.offset(1);
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr = (*i_ptr >> 16usize) as u32;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = (*i_ptr as u32) << 16usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= (*i_ptr >> 32usize) as u32;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr as u32;
//! }
//!
//! unsafe fn decode_u64_48_8(s_ptr: *const u32, o_ptr: *mut u64) {
//!     let mut s_ptr = s_ptr;
//!     let mut o_ptr = o_ptr;
//!     *o_ptr = (*s_ptr as u64) << 16usize;
//!     s_ptr = s_ptr.offset(1);
//!     *o_ptr |= (*s_ptr >> 16usize) as u64;
//!     o_ptr = o_ptr.offset(1);
//!     *o_ptr = ((*s_ptr & 65535u32) as u64) << 32usize;
//!     s_ptr = s_ptr.offset(1);
//!     *o_ptr |= *s_ptr as u64;
//!     s_ptr = s_ptr.offset(1);
//!     o_ptr = o_ptr.offset(1);
//!     *o_ptr = (*s_ptr as u64) << 16usize;
//!     s_ptr = s_ptr.offset(1);
//!     *o_ptr |= (*s_ptr >> 16usize) as u64;
//!     o_ptr = o_ptr.offset(1);
//!     *o_ptr = ((*s_ptr & 65535u32) as u64) << 32usize;
//!     s_ptr = s_ptr.offset(1);
//!     *o_ptr |= *s_ptr as u64;
//!     s_ptr = s_ptr.offset(1);
//!     o_ptr = o_ptr.offset(1);
//!     *o_ptr = (*s_ptr as u64) << 16usize;
//!     s_ptr = s_ptr.offset(1);
//!     *o_ptr |= (*s_ptr >> 16usize) as u64;
//!     o_ptr = o_ptr.offset(1);
//!     *o_ptr = ((*s_ptr & 65535u32) as u64) << 32usize;
//!     s_ptr = s_ptr.offset(1);
//!     *o_ptr |= *s_ptr as u64;
//!     s_ptr = s_ptr.offset(1);
//!     o_ptr = o_ptr.offset(1);
//!     *o_ptr = (*s_ptr as u64) << 16usize;
//!     s_ptr = s_ptr.offset(1);
//!     *o_ptr |= (*s_ptr >> 16usize) as u64;
//!     o_ptr = o_ptr.offset(1);
//!     *o_ptr = ((*s_ptr & 65535u32) as u64) << 32usize;
//!     s_ptr = s_ptr.offset(1);
//!     *o_ptr |= *s_ptr as u64;
//! }
//! ```

#![feature(plugin_registrar)]
#![feature(rustc_private)]
#![feature(quote)]
#![feature(inclusive_range_syntax)]

// Unused import in quote_tokens!
#![allow(unused_imports)]

extern crate rustc_plugin;
extern crate simd;
extern crate syntax;

use rustc_plugin::Registry;
use syntax::ast;
use syntax::codemap;
use syntax::ext::base::{DummyResult, ExtCtxt, MacResult, MacEager};
use syntax::fold::Folder;
use syntax::parse::token;
use syntax::print::pprust;
use syntax::util::small_vector;

/// Registers the encode and decode syntax expansions.
#[plugin_registrar]
pub fn plugin_registrar(reg: &mut Registry) {
  reg.register_macro("encode", encode_expand);
  reg.register_macro("decode", decode_expand);
  reg.register_macro("encode_simd", encode_simd_expand);
  reg.register_macro("decode_simd", decode_simd_expand);
}

/// Generates ENCODE_T containing function pointers, with the pointer for
/// encode_T_a_b at ENCODE_T[a - 1][b / c - 1].
fn encode_expand(cx: &mut ExtCtxt,
                 sp: codemap::Span,
                 tts: &[ast::TokenTree]) -> Box<MacResult + 'static> {
  // Arguments to the macro
  let (path, width, step) = {
    match parse(cx, sp, tts) {
      Some(x) => x,
      None => return DummyResult::expr(sp)
    }
  };
  
  // Number of integers encoded
  let lengths: Vec<usize> = (1...(32 / step)).map(|a| a * step).collect();

  // idents: tokens used to define the ENCODE_T
  // items: definitions of the functions
  let mut idents = vec![token::OpenDelim(token::Bracket)];
  let mut items = Vec::new();
  for wd in 1...width {
    idents.push(token::OpenDelim(token::Bracket));
    for ln in lengths.iter() {
      // Names for the functions directly interned
      let name = format!("encode_{}_{}_{}", path, wd, ln);
      let ident = ast::Ident::with_empty_ctxt(token::intern(&*name));
      idents.push(token::Ident(ident, token::Plain));
      idents.push(token::Comma);

      // Function definition constructed here
      let mut i_bits: usize;
      let mut s_bits: usize = 32;
      let mut tokens = quote_tokens!(cx, *s_ptr =);

      // For every integer to be encoded...
      for a in 0..*ln {
        i_bits = wd;
        // While the integer requires more bits than the current word...
        while i_bits > s_bits {
          let rsft = i_bits - s_bits;
          tokens = {
            if rsft == 0 {
              quote_tokens!(cx, $tokens *i_ptr as u32;)
            } else {
              quote_tokens!(cx, $tokens (*i_ptr >> $rsft) as u32;)
            }
          };

          i_bits -= s_bits;
          s_bits = 32;

          tokens = quote_tokens!(cx,
            $tokens
            s_ptr = s_ptr.offset(1);
            *s_ptr =
          );
        }
        // Encode any bits that remain
        let lsft = s_bits - i_bits;
        tokens = {
          if lsft == 0 {
            quote_tokens!(cx, $tokens *i_ptr as u32;)
          } else {
            quote_tokens!(cx, $tokens (*i_ptr as u32) << $lsft;)
          }
        };

        s_bits -= i_bits;
        if a < (*ln - 1) {
          tokens = quote_tokens!(cx,
            $tokens
            i_ptr = i_ptr.offset(1);
          );

          if s_bits == 0 {
            s_bits = 32;
            tokens = quote_tokens!(cx,
              $tokens
              s_ptr = s_ptr.offset(1);
              *s_ptr =
            );
          } else {
            tokens = quote_tokens!(cx,
              $tokens
              *s_ptr |=
            );
          }
        }
      }

      // Function definition pushed to items
      let item = quote_item!(cx,
        unsafe fn $ident(i_ptr: *const $path, s_ptr: *mut u32) {
          let mut i_ptr = i_ptr;
          let mut s_ptr = s_ptr;
          $tokens
        }
      ).unwrap();
      items.push(item);
    }
    idents.push(token::CloseDelim(token::Bracket));
    idents.push(token::Comma);
  }
  idents.push(token::CloseDelim(token::Bracket));

  // idents converted from tokens to TokenTree
  let ttree: Vec<ast::TokenTree> = idents
    .into_iter()
    .map(|token| ast::TokenTree::Token(codemap::DUMMY_SP, token))
    .collect();

  // ENCODE_T definition pushed to items
  let name = format!("encode_{}", path).to_uppercase();
  let ident = ast::Ident::with_empty_ctxt(token::intern(&*name));
  let ln = lengths.len();
  items.push(
    quote_item!(cx,
      pub const $ident: [[unsafe fn(*const $path, *mut u32); $ln]; $width] = $ttree;
    ).unwrap()
  );
  
  // DEBUGGING
  // for item in &items { println!("{}", pprust::item_to_string(item)); }

  MacEager::items(small_vector::SmallVector::many(items))
}

/// Generates DECODE_T containing function pointers, with the pointer for
/// decode_T_a_b at DECODE_T[a - 1][b - 1].
fn decode_expand(cx: &mut ExtCtxt,
                 sp: codemap::Span,
                 tts: &[ast::TokenTree]) -> Box<MacResult + 'static> {
  // Arguments to the macro
  let (path, width, step) = {
    match parse(cx, sp, tts) {
      Some(x) => x,
      None => return DummyResult::expr(sp)
    }
  };

  // Number of integers encoded
  let lengths: Vec<usize> = (1...(32 / step)).map(|a| a * step).collect();

  // Used to construct a function body
  let mut block = ast::Block {
    stmts: Vec::new(),
    expr: None,
    id: ast::DUMMY_NODE_ID,
    rules: ast::BlockCheckMode::Default,
    span: codemap::DUMMY_SP,
  };

  // idents: tokens used to define the const DECODE_T
  // items: definitions of the functions
  let mut idents = vec![token::OpenDelim(token::Bracket)];
  let mut items = Vec::new();
  for wd in 1...width {
    idents.push(token::OpenDelim(token::Bracket));
    for ln in lengths.iter() {
      // Names for the functions directly interned
      let name = format!("decode_{}_{}_{}", path, wd, ln);
      let ident = ast::Ident::with_empty_ctxt(token::intern(&*name));
      idents.push(token::Ident(ident, token::Plain));
      idents.push(token::Comma);

      // Function definition constructed here
      block.stmts.clear();
      let mut o_bits: usize;
      let mut s_bits: usize = 32;
      let mut tokens;
      // For every integer to be decoded...
      for _ in 0..*ln {
        o_bits = wd;
        tokens = quote_tokens!(cx, *o_ptr =);
        // While the integer requires more bits than the current word...
        while o_bits > s_bits {
          let mask = !0u32 >> (32 - s_bits);
          let lsft = o_bits - s_bits;
          let stmt = {
            match (s_bits, lsft) {
              (32, 0) => {
                quote_stmt!(cx, $tokens *s_ptr as $path;)
              }
              (32, _) => {
                quote_stmt!(cx, $tokens (*s_ptr as $path) << $lsft;)
              }
              (_, 0) => {
                quote_stmt!(cx, $tokens (*s_ptr & $mask) as $path;)
              }
              (_, _) => {
                quote_stmt!(cx, $tokens ((*s_ptr & $mask) as $path) << $lsft;)
              }
            }
          }.unwrap();
          block.stmts.push(stmt);
          tokens = quote_tokens!(cx, *o_ptr |=);

          o_bits -= s_bits;
          s_bits = 32;

          let stmt = quote_stmt!(cx, s_ptr = s_ptr.offset(1);).unwrap();
          block.stmts.push(stmt);
        }

        // Decode any bits that remain
        let mask = !0u32 >> (32 - s_bits);
        let rsft = s_bits - o_bits;
        let stmt = {
          match (s_bits, rsft) {
            (32, 0) => {
              quote_stmt!(cx, $tokens *s_ptr as $path;)
            }
            (32, _) => {
              quote_stmt!(cx, $tokens (*s_ptr >> $rsft) as $path;)
            }
            (_, 0) => {
              quote_stmt!(cx, $tokens (*s_ptr & $mask) as $path;)
            }
            (_, _) => {
              quote_stmt!(cx, $tokens ((*s_ptr & $mask) >> $rsft) as $path;)
            }
          }
        }.unwrap();
        block.stmts.push(stmt);

        s_bits -= o_bits;
        if s_bits == 0 {
          s_bits = 32;

          let stmt = quote_stmt!(cx, s_ptr = s_ptr.offset(1);).unwrap();
          block.stmts.push(stmt);
        }

        let stmt = quote_stmt!(cx, o_ptr = o_ptr.offset(1);).unwrap();
        block.stmts.push(stmt);
      }
      // Remove unnecessary offsets
      block.stmts.pop();
      if s_bits == 32 { block.stmts.pop(); }

      // Function definition pushed to items
      let item = quote_item!(cx,
        unsafe fn $ident(s_ptr: *const u32, o_ptr: *mut $path) {
          let mut s_ptr = s_ptr;
          let mut o_ptr = o_ptr;
          $block
        }
      ).unwrap();
      items.push(item);
    }
    idents.push(token::CloseDelim(token::Bracket));
    idents.push(token::Comma);
  }
  idents.push(token::CloseDelim(token::Bracket));

  // idents converted from tokens to TokenTree
  let ttree: Vec<ast::TokenTree> = idents
    .into_iter()
    .map(|token| ast::TokenTree::Token(codemap::DUMMY_SP, token))
    .collect();

  // DECODE_T definition pushed to items
  let name = format!("decode_{}", path).to_uppercase();
  let ident = ast::Ident::with_empty_ctxt(token::intern(&*name));
  let ln = lengths.len();
  items.push(
    quote_item!(cx,
      pub const $ident: [[unsafe fn(*const u32, *mut $path); $ln]; $width] = $ttree;
    ).unwrap()
  );
  
  // DEBUGGING
  // for item in &items { println!("{}", pprust::item_to_string(item)); }

  MacEager::items(small_vector::SmallVector::many(items))
}

/// Parse the three arguments to the encode and decode syntax extensions.
fn parse(cx: &mut ExtCtxt,
         sp: codemap::Span,
         tts: &[ast::TokenTree]) -> Option<(ast::Path, usize, usize)> {
  let mut parser = cx.new_parser_from_tts(tts);

  let entry = cx.expander().fold_expr(parser.parse_expr().unwrap());
  let path = {
    match entry.node {
      ast::ExprKind::Path(_, ref p) => p.clone(),
      _ => {
        cx.span_err(entry.span, &format!(
          "expected type but got '{}'",
          pprust::expr_to_string(&*entry)));
        return None
      }
    }
  };
  parser.eat(&token::Comma);

  let entry = cx.expander().fold_expr(parser.parse_expr().unwrap());
  let width = {
    match entry.node {
      ast::ExprKind::Lit(ref lit) => {
        match lit.node {
          ast::LitKind::Int(n, _) => n,
          _ => {
            cx.span_err(entry.span, &format!(
                "expected integer literal but got '{}'",
                pprust::lit_to_string(&**lit)));
            return None
          }
        }
      }
      _ => {
        cx.span_err(entry.span, &format!(
            "expected integer literal but got '{}'",
            pprust::expr_to_string(&*entry)));
        return None }
    }
  };
  parser.eat(&token::Comma);

  let entry = cx.expander().fold_expr(parser.parse_expr().unwrap());
  let step = {
    match entry.node {
      ast::ExprKind::Lit(ref lit) => {
        match lit.node {
          ast::LitKind::Int(n, _) => n,
          _ => {
            cx.span_err(entry.span, &format!(
                "expected integer literal but got '{}'",
                pprust::lit_to_string(&**lit)));
            return None
          }
        }
      }
      _ => {
        cx.span_err(entry.span, &format!(
            "expected integer literal but got '{}'",
            pprust::expr_to_string(&*entry)));
        return None }
    }
  };
  assert_eq!(32 % step, 0);
  parser.eat(&token::Comma);

  if parser.token != token::Eof {
    cx.span_err(sp, "expected exactly three arguments");
    return None
  }

  Some((path, width as usize, step as usize))
}

/// Generates ENCODE_SIMD_T containing function pointers, with the
/// pointer for encode_T_a_b at ENCODE_SIMD_T[a - 1][b / c - 1].
fn encode_simd_expand(cx: &mut ExtCtxt,
                      sp: codemap::Span,
                      tts: &[ast::TokenTree]) -> Box<MacResult + 'static> {
  // Arguments to the macro
  let (path, width) = {
    match parse_simd(cx, sp, tts) {
      Some(x) => x,
      None => return DummyResult::expr(sp)
    }
  };
  
  // idents: tokens used to define the ENCODE_SIMD_T
  // items: definitions of the functions
  let mut idents = vec![token::OpenDelim(token::Bracket)];
  let mut items = Vec::new();
  for wd in 1...width {
    // Names for the functions directly interned
    let name = format!("encode_simd_{}_{}", path, wd);
    let ident = ast::Ident::with_empty_ctxt(token::intern(&*name));
    idents.push(token::Ident(ident, token::Plain));
    idents.push(token::Comma);

    // Function definition constructed here
    let mut i_bits: usize;
    let mut s_bits: usize = 32;

    // Initialize the u32x4
    let mut tokens = quote_tokens!(cx,
      let mut lhs = simd::u32x4::splat(0);
    );

    // For every integer to be encoded...
    for a in 0..32 {
      i_bits = wd;
      // While the integer requires more bits than the current word...
      while i_bits > s_bits {
        let rsft = i_bits - s_bits;
        tokens = {
          if rsft == 0 {
            quote_tokens!(cx,
              $tokens
              let rhs = simd::u32x4::new(
                *i_ptr as u32,
                *i_ptr.offset(1) as u32,
                *i_ptr.offset(2) as u32,
                *i_ptr.offset(3) as u32
              );
              lhs = lhs | rhs;
            )
          } else {
            quote_tokens!(cx,
              $tokens
              let rhs = simd::u32x4::new(
                (*i_ptr >> $rsft) as u32,
                (*i_ptr.offset(1) >> $rsft) as u32,
                (*i_ptr.offset(2) >> $rsft) as u32,
                (*i_ptr.offset(3) >> $rsft) as u32
              );
              lhs = lhs | rhs;
            )
          }
        };

        i_bits -= s_bits;
        s_bits = 32;

        tokens = quote_tokens!(cx,
          $tokens
          lhs.store(std::slice::from_raw_parts_mut(s_ptr, 4), 0);
          s_ptr = s_ptr.offset(4);
          lhs = simd::u32x4::splat(0);
        );
      }
      // Encode any bits that remain
      let lsft = s_bits - i_bits;
      tokens = {
        if lsft == 0 {
          quote_tokens!(cx,
            $tokens
            let rhs = simd::u32x4::new(
              *i_ptr as u32,
              *i_ptr.offset(1) as u32,
              *i_ptr.offset(2) as u32,
              *i_ptr.offset(3) as u32
            );
            lhs = lhs | rhs;
          )
        } else {
          quote_tokens!(cx,
            $tokens
            let rhs = simd::u32x4::new(
              *i_ptr as u32,
              *i_ptr.offset(1) as u32,
              *i_ptr.offset(2) as u32,
              *i_ptr.offset(3) as u32
            );
            lhs = lhs | (rhs << $lsft);
          )
        }
      };

      s_bits -= i_bits;
      if s_bits == 0 {
        s_bits = 32;
        
        tokens = quote_tokens!(cx,
          $tokens
          lhs.store(std::slice::from_raw_parts_mut(s_ptr, 4), 0);
        );
        if a < 31 {
          tokens = quote_tokens!(cx,
            $tokens
            s_ptr = s_ptr.offset(4);
            lhs = simd::u32x4::splat(0);
          );
        }
      }
      if a < 31 {
        tokens = quote_tokens!(cx,
          $tokens
          i_ptr = i_ptr.offset(4);
        );
      }
    }

    // Function definition pushed to items
    let item = quote_item!(cx,
      unsafe fn $ident(i_ptr: *const $path, s_ptr: *mut u32) {
        let mut i_ptr = i_ptr;
        let mut s_ptr = s_ptr;
        $tokens
      }
    ).unwrap();
    items.push(item);
  }
  idents.push(token::CloseDelim(token::Bracket));

  // idents converted from tokens to TokenTree
  let ttree: Vec<ast::TokenTree> = idents
    .into_iter()
    .map(|token| ast::TokenTree::Token(codemap::DUMMY_SP, token))
    .collect();

  // ENCODE_T_ARRAY definition pushed to items
  let name = format!("encode_simd_{}", path).to_uppercase();
  let ident = ast::Ident::with_empty_ctxt(token::intern(&*name));
  items.push(
    quote_item!(cx,
      pub const $ident: [unsafe fn(*const $path, *mut u32); $width] = $ttree;
    ).unwrap()
  );

  // DEBUGGING
  // for item in &items { println!("{}", pprust::item_to_string(item)); }

  MacEager::items(small_vector::SmallVector::many(items))
}

/// Generates DECODE_SIMD_T containing function pointers, with the
/// pointer for decode_T_a_b at DECODE_SIMD_T[a - 1][b - 1].
fn decode_simd_expand(cx: &mut ExtCtxt,
                      sp: codemap::Span,
                      tts: &[ast::TokenTree]) -> Box<MacResult + 'static> {
  // Arguments to the macro
  let (path, width) = {
    match parse_simd(cx, sp, tts) {
      Some(x) => x,
      None => return DummyResult::expr(sp)
    }
  };

  // idents: tokens used to define the const DECODE_SIMD_T
  // items: definitions of the functions
  let mut idents = vec![token::OpenDelim(token::Bracket)];
  let mut items = Vec::new();
  for wd in 1...width {
    // Names for the functions directly interned
    let name = format!("decode_simd_{}_{}", path, wd);
    let ident = ast::Ident::with_empty_ctxt(token::intern(&*name));
    idents.push(token::Ident(ident, token::Plain));
    idents.push(token::Comma);

    // Function definition constructed here
    let mut o_bits: usize;
    let mut s_bits: usize = 32;

    // Initialize the u32x4
    let mut tokens = quote_tokens!(cx,
      let rhs = simd::u32x4::load(std::slice::from_raw_parts(s_ptr, 4), 0);
    );

    // For every integer to be decoded...
    for a in 0..32 {
      o_bits = wd;
      tokens = quote_tokens!(cx,
        $tokens
        *o_ptr = 0;
        *o_ptr.offset(1) = 0;
        *o_ptr.offset(2) = 0;
        *o_ptr.offset(3) = 0;
      );
      // While the integer requires more bits than the current word...
      while o_bits > s_bits {
        let mask = !0u32 >> (32 - s_bits);
        let lsft = o_bits - s_bits;
        tokens = {
          match (s_bits, lsft) {
            (32, 0) => {
              quote_tokens!(cx,
                $tokens
                *o_ptr |= rhs.extract(0) as $path;
                *o_ptr.offset(1) |= rhs.extract(1) as $path;
                *o_ptr.offset(2) |= rhs.extract(2) as $path;
                *o_ptr.offset(3) |= rhs.extract(3) as $path;
              )
            }
            (32, _) => {
              quote_tokens!(cx,
                $tokens
                *o_ptr |= (rhs.extract(0) as $path) << $lsft;
                *o_ptr.offset(1) |= (rhs.extract(1) as $path) << $lsft;
                *o_ptr.offset(2) |= (rhs.extract(2) as $path) << $lsft;
                *o_ptr.offset(3) |= (rhs.extract(3) as $path) << $lsft;
              )
            }
            (_, 0) => {
              quote_tokens!(cx,
                $tokens
                let lhs = rhs & simd::u32x4::splat($mask);
                *o_ptr |= lhs.extract(0) as $path;
                *o_ptr.offset(1) |= lhs.extract(1) as $path;
                *o_ptr.offset(2) |= lhs.extract(2) as $path;
                *o_ptr.offset(3) |= lhs.extract(3) as $path;
              )
            }
            (_, _) => {
              quote_tokens!(cx,
                $tokens
                let lhs = rhs & simd::u32x4::splat($mask);
                *o_ptr |= (lhs.extract(0) as $path) << $lsft;
                *o_ptr.offset(1) |= (lhs.extract(1) as $path) << $lsft;
                *o_ptr.offset(2) |= (lhs.extract(2) as $path) << $lsft;
                *o_ptr.offset(3) |= (lhs.extract(3) as $path) << $lsft;
              )
            }
          }
        };

        o_bits -= s_bits;
        s_bits = 32;

        tokens = quote_tokens!(cx,
          $tokens
          s_ptr = s_ptr.offset(4);
          let rhs = simd::u32x4::load(std::slice::from_raw_parts(s_ptr, 4), 0);
        );
      }
      // Decode any bits that remain
      let mask = !0u32 >> (32 - s_bits);
      let rsft = s_bits - o_bits;
      tokens = {
        match (s_bits, rsft) {
          (32, 0) => {
            quote_tokens!(cx,
              $tokens
              *o_ptr |= rhs.extract(0) as $path;
              *o_ptr.offset(1) |= rhs.extract(1) as $path;
              *o_ptr.offset(2) |= rhs.extract(2) as $path;
              *o_ptr.offset(3) |= rhs.extract(3) as $path;
            )
          }
          (32, _) => {
            quote_tokens!(cx,
              $tokens
              let lhs = rhs >> $rsft;
              *o_ptr |= lhs.extract(0) as $path;
              *o_ptr.offset(1) |= lhs.extract(1) as $path;
              *o_ptr.offset(2) |= lhs.extract(2) as $path;
              *o_ptr.offset(3) |= lhs.extract(3) as $path;
            )
          }
          (_, 0) => {
            quote_tokens!(cx,
              $tokens
              let lhs = rhs & simd::u32x4::splat($mask);
              *o_ptr |= lhs.extract(0) as $path;
              *o_ptr.offset(1) |= lhs.extract(1) as $path;
              *o_ptr.offset(2) |= lhs.extract(2) as $path;
              *o_ptr.offset(3) |= lhs.extract(3) as $path;
            )
          }
          (_, _) => {
            quote_tokens!(cx,
              $tokens
              let lhs = (rhs & simd::u32x4::splat($mask)) >> $rsft;
              *o_ptr |= lhs.extract(0) as $path;
              *o_ptr.offset(1) |= lhs.extract(1) as $path;
              *o_ptr.offset(2) |= lhs.extract(2) as $path;
              *o_ptr.offset(3) |= lhs.extract(3) as $path;
            )
          }
        }
      };

      s_bits -= o_bits;
      if s_bits == 0 {
        s_bits = 32;

        if a < 31 {
          tokens = quote_tokens!(cx,
            $tokens
            s_ptr = s_ptr.offset(4);
            let rhs = simd::u32x4::load(std::slice::from_raw_parts(s_ptr, 4), 0);
          );
        }
      }
      if a < 31 {
        tokens = quote_tokens!(cx,
          $tokens
          o_ptr = o_ptr.offset(4);
        );
      }
    }

    // Function definition pushed to items
    let item = quote_item!(cx,
      unsafe fn $ident(s_ptr: *const u32, o_ptr: *mut $path) {
        let mut s_ptr = s_ptr;
        let mut o_ptr = o_ptr;
        $tokens
      }
    ).unwrap();
    items.push(item);
  }
  idents.push(token::CloseDelim(token::Bracket));

  // idents converted from tokens to TokenTree
  let ttree: Vec<ast::TokenTree> = idents
    .into_iter()
    .map(|token| ast::TokenTree::Token(codemap::DUMMY_SP, token))
    .collect();

  // DECODE_T definition pushed to items
  let name = format!("decode_simd_{}", path).to_uppercase();
  let ident = ast::Ident::with_empty_ctxt(token::intern(&*name));
  items.push(
    quote_item!(cx,
      pub const $ident: [unsafe fn(*const u32, *mut $path); $width] = $ttree;
    ).unwrap()
  );
  
  // DEBUGGING
  // for item in &items { println!("{}", pprust::item_to_string(item)); }

  MacEager::items(small_vector::SmallVector::many(items))
}

/// Parse the two arguments to the encode and decode syntax extensions.
fn parse_simd(cx: &mut ExtCtxt,
              sp: codemap::Span,
              tts: &[ast::TokenTree]) -> Option<(ast::Path, usize)> {
  let mut parser = cx.new_parser_from_tts(tts);

  let entry = cx.expander().fold_expr(parser.parse_expr().unwrap());
  let path = {
    match entry.node {
      ast::ExprKind::Path(_, ref p) => p.clone(),
      _ => {
        cx.span_err(entry.span, &format!(
          "expected type but got '{}'",
          pprust::expr_to_string(&*entry)));
        return None
      }
    }
  };
  parser.eat(&token::Comma);

  let entry = cx.expander().fold_expr(parser.parse_expr().unwrap());
  let width = {
    match entry.node {
      ast::ExprKind::Lit(ref lit) => {
        match lit.node {
          ast::LitKind::Int(n, _) => n,
          _ => {
            cx.span_err(entry.span, &format!(
                "expected integer literal but got '{}'",
                pprust::lit_to_string(&**lit)));
            return None
          }
        }
      }
      _ => {
        cx.span_err(entry.span, &format!(
            "expected integer literal but got '{}'",
            pprust::expr_to_string(&*entry)));
        return None }
    }
  };
  parser.eat(&token::Comma);

  if parser.token != token::Eof {
    cx.span_err(sp, "expected exactly two arguments");
    return None
  }

  Some((path, width as usize))
}
