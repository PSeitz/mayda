// Copyright 2016 Jeremy Mason
//
// Licensed under the MIT license <LICENSE or
// http://opensource.org/licenses/MIT>. This file may not be copied, modified,
// or distributed except according to those terms.

//! Compiler plugin to generate basic encoding and decoding functions. The
//! generated functions follow the convention encode_T_b and decode_T_b, where
//! T is one of the unsigned integer types and b is the number of bits per
//! integer. The number of integers encoded and decoded is always 32.
//!
//! The encode! and decode! syntax extensions take as arguments the unsigned
//! integer type and the type width in bits. Functions are generated for
//! numbers of bits in the interval 1...type_width.
//!
//! Pointers to the generated functions are available in ENCODE_T and DECODE_T.
//! These are public constant arrays, with the pointer for encode_T_b at 
//! ENCODE_T[b - 1].
//! 
//! # Safety
//!
//! The functions generated by this crate use wildly unsafe pointer operations.
//! You must verify that enough memory is already allocated after the pointers
//! that the offsets are valid. They are not intended to be used outside the
//! pfor crate.
//! 
//! # Examples
//!
//! The syntax extensions defined in this crate can be invoked as
//!
//! ```
//! encode!(u32, 32);
//! decode!(u32, 32);
//! ```
//!
//! This is replaced by 32 functions that encode u16 integers and 32 functions
//! that decode u16 integers. For example, the functions that encode and decode
//! the 24 least significant bits of 32 u32 integers are
//!
//! ````
//! unsafe fn encode_u32_24(i_ptr: *const u32, s_ptr: *mut u32) {
//!     let mut i_ptr = i_ptr;
//!     let mut s_ptr = s_ptr as *mut u32;
//!     *s_ptr = *i_ptr;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 24usize;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr >> 8usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 16usize;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr >> 16usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 8usize;
//!     i_ptr = i_ptr.offset(1);
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 24usize;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr >> 8usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 16usize;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr >> 16usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 8usize;
//!     i_ptr = i_ptr.offset(1);
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 24usize;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr >> 8usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 16usize;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr >> 16usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 8usize;
//!     i_ptr = i_ptr.offset(1);
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 24usize;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr >> 8usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 16usize;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr >> 16usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 8usize;
//!     i_ptr = i_ptr.offset(1);
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 24usize;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr >> 8usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 16usize;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr >> 16usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 8usize;
//!     i_ptr = i_ptr.offset(1);
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 24usize;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr >> 8usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 16usize;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr >> 16usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 8usize;
//!     i_ptr = i_ptr.offset(1);
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 24usize;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr >> 8usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 16usize;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr >> 16usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 8usize;
//!     i_ptr = i_ptr.offset(1);
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 24usize;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr >> 8usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 16usize;
//!     s_ptr = s_ptr.offset(1);
//!     *s_ptr = *i_ptr >> 16usize;
//!     i_ptr = i_ptr.offset(1);
//!     *s_ptr |= *i_ptr << 8usize;
//! }
//! ```

#![feature(plugin_registrar)]
#![feature(rustc_private)]
#![feature(quote)]
#![feature(inclusive_range_syntax)]

// Unused import in quote_tokens! macro
#![allow(unused_imports)]

extern crate rustc_plugin;
extern crate syntax;

use rustc_plugin::Registry;
use syntax::ast;
use syntax::codemap;
use syntax::ext::base::{DummyResult, ExtCtxt, MacResult, MacEager};
use syntax::fold::Folder;
use syntax::parse::token;
use syntax::print::pprust;
use syntax::util::small_vector;
use std::cmp::Ordering;

/// Registers the encode and decode syntax expansions.
#[plugin_registrar]
pub fn plugin_registrar(reg: &mut Registry) {
  reg.register_macro("encode_native", encode_native_expand);
  reg.register_macro("decode_native", decode_native_expand);
}

/// Generates ENCODE_NATIVE_T containing function pointers, with the pointer for
/// encode_native_T_b at ENCODE_NATIVE_T[b - 1].
fn encode_native_expand(cx: &mut ExtCtxt,
                        sp: codemap::Span,
                        tts: &[ast::TokenTree]) -> Box<MacResult + 'static> {
  // Arguments to the macro invocation
  let (path, width) = {
    match parse_native(cx, sp, tts) {
      Some(x) => x,
      None => return DummyResult::expr(sp)
    }
  };
  
  // idents: tokens used to define the ENCODE_T
  // items: definitions of the functions
  let mut idents = vec![token::OpenDelim(token::Bracket)];
  let mut items = Vec::new();
  for wd in 1...width {
    // Names for the functions directly interned
    let name = format!("encode_native_{}_{}", path, wd);
    let ident = ast::Ident::with_empty_ctxt(token::intern(&*name));
    idents.push(token::Ident(ident, token::Plain));
    idents.push(token::Comma);

    // Function definition constructed here
    let mut s_bits: usize = width;
    let mut tokens = quote_tokens!(cx, *s_ptr =);

    // For every integer to be encoded...
    for a in 0..64 {
      let lsft = width - s_bits;
      if lsft == 0 {
        tokens = quote_tokens!(cx, $tokens
          *i_ptr;
        );
      } else {
        tokens = quote_tokens!(cx, $tokens
          *i_ptr << $lsft;
        );
      }

      if s_bits < wd {
        tokens = quote_tokens!(cx, $tokens
          s_ptr = s_ptr.offset(1);
          *s_ptr = *i_ptr >> $s_bits;
        );
      }

      if a < 63 {
        tokens = quote_tokens!(cx, $tokens
          i_ptr = i_ptr.offset(1);
        );
        match s_bits.cmp(&wd) {
          Ordering::Greater => {
            tokens = quote_tokens!(cx, $tokens
              *s_ptr |=
            );
            s_bits -= wd;
          }
          Ordering::Equal => {
            tokens = quote_tokens!(cx, $tokens
              s_ptr = s_ptr.offset(1);
              *s_ptr =
            );
            s_bits = width;
          }
          Ordering::Less => {
            tokens = quote_tokens!(cx, $tokens
              *s_ptr |=
            );
            s_bits = width + s_bits - wd;
          }
        }
      }
    }

    // Function definition pushed to items
    let item = quote_item!(cx,
      unsafe fn $ident(i_ptr: *const $path, s_ptr: *mut u32) {
        let mut i_ptr = i_ptr;
        let mut s_ptr = s_ptr as *mut $path;
        $tokens
      }
    ).unwrap();
    items.push(item);
  }
  idents.push(token::CloseDelim(token::Bracket));

  // idents converted from tokens to TokenTree
  let ttree: Vec<ast::TokenTree> = idents
    .into_iter()
    .map(|token| ast::TokenTree::Token(codemap::DUMMY_SP, token))
    .collect();

  // ENCODE_T definition pushed to items
  let name = format!("encode_native_{}", path).to_uppercase();
  let ident = ast::Ident::with_empty_ctxt(token::intern(&*name));
  items.push(
    quote_item!(cx,
      pub const $ident: [unsafe fn(*const $path, *mut u32); $width] = $ttree;
    ).unwrap()
  );
  
  // DEBUGGING
  // for item in &items { println!("{}", pprust::item_to_string(item)); }

  MacEager::items(small_vector::SmallVector::many(items))
}

/// Generates DECODE_NATIVE_T containing function pointers, with the pointer
/// for decode_native_T_b at DECODE_NATIVE_T[b - 1].
fn decode_native_expand(cx: &mut ExtCtxt,
                 sp: codemap::Span,
                 tts: &[ast::TokenTree]) -> Box<MacResult + 'static> {
  // Arguments to the macro invocation
  let (path, width) = {
    match parse_native(cx, sp, tts) {
      Some(x) => x,
      None => return DummyResult::expr(sp)
    }
  };

  // idents: tokens used to define the const DECODE_T
  // items: definitions of the functions
  let mut idents = vec![token::OpenDelim(token::Bracket)];
  let mut items = Vec::new();
  for wd in 1...width {
    // Names for the functions directly interned
    let name = format!("decode_native_{}_{}", path, wd);
    let ident = ast::Ident::with_empty_ctxt(token::intern(&*name));
    idents.push(token::Ident(ident, token::Plain));
    idents.push(token::Comma);

    // Function definition constructed here
    let mask_sft = width - wd;
    let mut s_bits: usize = width;
    let mut tokens: Vec<ast::TokenTree> = Vec::new();
    if mask_sft > 0 {
      tokens = quote_tokens!(cx,
        let mask: $path = !0 >> $mask_sft;
      );
    };

    // For every integer to be decoded...
    for a in 0..64 {
      tokens = quote_tokens!(cx, $tokens
        *o_ptr =
      );

      let rsft = width - s_bits;
      tokens = match s_bits.cmp(&wd) {
        Ordering::Greater => {
          if rsft == 0 {
            quote_tokens!(cx, $tokens
              *s_ptr & mask;
            )
          } else {
            quote_tokens!(cx, $tokens
              (*s_ptr >> $rsft) & mask;
            )
          }
        }
        Ordering::Equal => {
          if rsft == 0 {
            quote_tokens!(cx, $tokens
              *s_ptr;
            )
          } else {
            quote_tokens!(cx, $tokens
              *s_ptr >> $rsft;
            )
          }
        }
        Ordering::Less => {
          quote_tokens!(cx, $tokens
            *s_ptr >> $rsft;
            s_ptr = s_ptr.offset(1);
            *o_ptr |= (*s_ptr << $s_bits) & mask;
          )
        }
      };
      
      if a < 63 {
        tokens = quote_tokens!(cx, $tokens
          o_ptr = o_ptr.offset(1);
        );
        match s_bits.cmp(&wd) {
          Ordering::Greater => {
            s_bits -= wd;
          }
          Ordering::Equal => {
            tokens = quote_tokens!(cx, $tokens
              s_ptr = s_ptr.offset(1); 
            );
            s_bits = width;
          }
          Ordering::Less => {
            s_bits = width + s_bits - wd;
          }
        }
      }
    }

    // Function definition pushed to items
    let item = quote_item!(cx,
      unsafe fn $ident(s_ptr: *const u32, o_ptr: *mut $path) {
        let mut s_ptr = s_ptr as *const $path;
        let mut o_ptr = o_ptr;
        $tokens
      }
    ).unwrap();
    items.push(item);
  }
  idents.push(token::CloseDelim(token::Bracket));

  // idents converted from tokens to TokenTree
  let ttree: Vec<ast::TokenTree> = idents
    .into_iter()
    .map(|token| ast::TokenTree::Token(codemap::DUMMY_SP, token))
    .collect();

  // DECODE_T definition pushed to items
  let name = format!("decode_native_{}", path).to_uppercase();
  let ident = ast::Ident::with_empty_ctxt(token::intern(&*name));
  items.push(
    quote_item!(cx,
      pub const $ident: [unsafe fn(*const u32, *mut $path); $width] = $ttree;
    ).unwrap()
  );
  
  // DEBUGGING
  // for item in &items { println!("{}", pprust::item_to_string(item)); }

  MacEager::items(small_vector::SmallVector::many(items))
}

/// Parse the two arguments to the encode_native and decode_native syntax
/// extensions.
fn parse_native(cx: &mut ExtCtxt,
         sp: codemap::Span,
         tts: &[ast::TokenTree]) -> Option<(ast::Path, usize)> {
  let mut parser = cx.new_parser_from_tts(tts);

  let entry = cx.expander().fold_expr(parser.parse_expr().unwrap());
  let path = {
    match entry.node {
      ast::ExprKind::Path(_, ref p) => p.clone(),
      _ => {
        cx.span_err(entry.span, &format!(
          "expected type but got '{}'",
          pprust::expr_to_string(&*entry)));
        return None
      }
    }
  };
  parser.eat(&token::Comma);

  let entry = cx.expander().fold_expr(parser.parse_expr().unwrap());
  let width = {
    match entry.node {
      ast::ExprKind::Lit(ref lit) => {
        match lit.node {
          ast::LitKind::Int(n, _) => n,
          _ => {
            cx.span_err(entry.span, &format!(
                "expected integer literal but got '{}'",
                pprust::lit_to_string(&**lit)));
            return None
          }
        }
      }
      _ => {
        cx.span_err(entry.span, &format!(
            "expected integer literal but got '{}'",
            pprust::expr_to_string(&*entry)));
        return None }
    }
  };
  parser.eat(&token::Comma);

  if parser.token != token::Eof {
    cx.span_err(sp, "expected exactly three arguments");
    return None
  }

  Some((path, width as usize))
}
