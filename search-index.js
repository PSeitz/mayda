var searchIndex = {};
searchIndex["mayda"] = {"doc":"`mayda` is a library to compress integer arrays (all primitive integer\ntypes are supported). The design favors decompression speed and the ability\nto index the compressed array over the compression ratio, on the principle\nthat the runtime penalty for using compressed arrays should be as small as\npossible.","items":[[0,"error","mayda","Defines the `mayda::Error` type. Currently only used for the return types of\nfunctions defined in the `Encode` trait, but intended to allow for more\ncomplex error handling in the future.",null,null],[3,"Error","mayda::error","The `mayda::Error` type.",null,null],[11,"fmt","","",0,null],[11,"new","","Creates an empty Error object.",0,{"inputs":[{"name":"str"}],"output":{"name":"error"}}],[11,"description","","",0,null],[11,"fmt","","",0,null],[0,"monotone","mayda","`Monotone` encoding of integer arrays. Intended for cases where the entries\nare monotonically increasing. Implemented for all primitive integer types.  ",null,null],[3,"Monotone","mayda::monotone","The type of a monotone encoded integer array. Designed for moderate\ncompression and efficient decoding through the `Encode` trait, and\nefficient random access through the `Access` and `AccessInto` traits.",null,null],[11,"partial_cmp","","",1,null],[11,"lt","","",1,null],[11,"le","","",1,null],[11,"gt","","",1,null],[11,"ge","","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"hash","","",1,null],[11,"default","","",1,{"inputs":[],"output":{"name":"monotone"}}],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"new","","Creates an empty `Monotone` object.",1,{"inputs":[],"output":{"name":"self"}}],[11,"from_slice","","Creates a `Monotone` object that encodes the slice.",1,null],[11,"is_empty","","Returns true when there are no encoded entries.",1,null],[11,"len","","Returns the number of encoded entries. Note that since the length has to\nbe calculated, `Monotone::len()` is more expensive than `Slice::len()`.",1,null],[11,"storage","","Exposes the word storage of the `Monotone` object.",1,null],[11,"mut_storage","","Exposes the mutable word storage of the `Monotone` object.",1,null],[11,"required_width","","Returns the width of the encoded integer type.",1,null],[11,"encode","","",1,null],[11,"decode","","",1,null],[11,"decode_into","","",1,null],[11,"access","","",1,null],[11,"access","","",1,null],[11,"access","","",1,null],[11,"access","","",1,null],[11,"access","","",1,null],[11,"access","","",1,null],[11,"access","","",1,null],[11,"access_into","","",1,null],[11,"access_into","","",1,null],[11,"access_into","","",1,null],[11,"access_into","","",1,null],[11,"access_into","","",1,null],[11,"access_into","","",1,null],[0,"uniform","mayda","`Uniform` encoding of integer arrays. Intended for cases where encoding and\ndecoding speed is desired, or the probability distribution of the entries\nis uniform within certain bounds. Implemented for all primitive integer\ntypes.",null,null],[3,"Uniform","mayda::uniform","The type of a uniform encoded integer array. Designed for moderate\ncompression and efficient decoding through the `Encode` trait, and\nefficient random access through the `Access` and `AccessInto` traits.",null,null],[11,"partial_cmp","","",2,null],[11,"lt","","",2,null],[11,"le","","",2,null],[11,"gt","","",2,null],[11,"ge","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"hash","","",2,null],[11,"default","","",2,{"inputs":[],"output":{"name":"uniform"}}],[11,"fmt","","",2,null],[11,"clone","","",2,null],[11,"new","","Creates an empty `Uniform` object.",2,{"inputs":[],"output":{"name":"self"}}],[11,"from_slice","","Creates a `Uniform` object that encodes the slice.",2,null],[11,"is_empty","","Returns true when there are no encoded entries.",2,null],[11,"len","","Returns the number of encoded entries. Note that since the length has to\nbe calculated, `Uniform::len()` is more expensive than `Slice::len()`.",2,null],[11,"storage","","Exposes the word storage of the `Uniform` object.",2,null],[11,"mut_storage","","Exposes the mutable word storage of the `Uniform` object.",2,null],[11,"required_width","","Returns the width of the encoded integer type.",2,null],[11,"encode","","",2,null],[11,"decode","","",2,null],[11,"decode_into","","",2,null],[11,"access","","",2,null],[11,"access","","",2,null],[11,"access","","",2,null],[11,"access","","",2,null],[11,"access","","",2,null],[11,"access","","",2,null],[11,"access","","",2,null],[11,"access_into","","",2,null],[11,"access_into","","",2,null],[11,"access_into","","",2,null],[11,"access_into","","",2,null],[11,"access_into","","",2,null],[11,"access_into","","",2,null],[0,"unimodal","mayda","`Unimodal` encoding of integer arrays. Intended for cases where information\nabout the probability distribution of the entries is not known, and the\npresence of outliers reduces the compression ratio of the other types.\nImplemented for all primitive integer types.",null,null],[3,"Unimodal","mayda::unimodal","The type of a unimodal encoded integer array. Designed for moderate\ncompression and efficient decoding through the `Encode` trait, and\nefficient random access through the `Access` and `AccessInto` traits.",null,null],[11,"partial_cmp","","",3,null],[11,"lt","","",3,null],[11,"le","","",3,null],[11,"gt","","",3,null],[11,"ge","","",3,null],[11,"eq","","",3,null],[11,"ne","","",3,null],[11,"hash","","",3,null],[11,"default","","",3,{"inputs":[],"output":{"name":"unimodal"}}],[11,"fmt","","",3,null],[11,"clone","","",3,null],[11,"new","","Creates an empty `Unimodal` object.",3,{"inputs":[],"output":{"name":"self"}}],[11,"from_slice","","Creates a `Unimodal` object that encodes the slice.",3,null],[11,"is_empty","","Returns true when there are no encoded entries.",3,null],[11,"len","","Returns the number of encoded entries. Note that since the length has to\nbe calculated, `Unimodal::len()` is more expensive than `Slice::len()`.",3,null],[11,"storage","","Exposes the word storage of the `Unimodal` object.",3,null],[11,"mut_storage","","Exposes the mutable word storage of the `Unimodal` object.",3,null],[11,"required_width","","Returns the width of the encoded integer type.",3,null],[11,"encode","","",3,null],[11,"decode","","",3,null],[11,"decode_into","","",3,null],[11,"access","","",3,null],[11,"access","","",3,null],[11,"access","","",3,null],[11,"access","","",3,null],[11,"access","","",3,null],[11,"access","","",3,null],[11,"access","","",3,null],[11,"access_into","","",3,null],[11,"access_into","","",3,null],[11,"access_into","","",3,null],[11,"access_into","","",3,null],[11,"access_into","","",3,null],[11,"access_into","","",3,null],[0,"utility","mayda","Contains constants, enums, traits and functions used by all of the encoding\ntypes provided by the `mayda` crate.",null,null],[5,"words_for_bits","mayda::utility","Returns number of words required to store the given number of bits. A word\nis 32 bits long.",null,{"inputs":[{"name":"u32"}],"output":{"name":"usize"}}],[5,"select_m","","A modified version of the Floyd-Rivest algorithm with fewer comparisions\nand fewer swaps, specialized for the case of slices with length &lt; 500. The\nmodifications may not be known in the literature. Intended to be used to\nfind the median of a block.",null,null],[8,"Bits","","Indicates that the bitwise representation of the type is known to `mayda`.\nIntended to be implemented only for the primitive integer types. Mainly\nused as a bound on the `Encode` trait.",null,null],[10,"width","","Number of bits in the standard representation.",4,{"inputs":[],"output":{"name":"u32"}}],[10,"bits","","Number of bits required to represent the number in binary. Notice that\n`0.bits() == 0u32` intentionally.",4,null],[8,"Encode","","Indicates that the type can be encoded and decoded by `mayda`.",null,null],[10,"encode","","Encodes the slice into the `Encode` object.",5,null],[10,"decode","","Decodes the contents of the `Encode` object. Returns a vector because\nownership of the returned value must be given to the caller.",5,null],[10,"decode_into","","Decodes the contents of the `Encode` object and writes the result into\nthe slice provided. More efficient than `decode` if the slice is already\nallocated. Returns the number of decoded entries.",5,null],[8,"Access","","A trait for indexing an encoded vector. Similar to but less convenient than\n`Index`. `Index::index()` returns a reference, but an encoded vector type\nmust give ownership of the returned value to the caller.",null,null],[16,"Output","","The type returned by the access operation.",6,null],[10,"access","","The method for the access `foo.access(bar)` operation.",6,null],[8,"AccessInto","","A trait for indexing a range of an encoded vector. Writes the result into\nthe slice provided. Similar to but less convenient than `Index`.",null,null],[10,"access_into","","The method for the access `foo.access_into(bar, slice)` operation.",7,null]],"paths":[[3,"Error"],[3,"Monotone"],[3,"Uniform"],[3,"Unimodal"],[8,"Bits"],[8,"Encode"],[8,"Access"],[8,"AccessInto"]]};
searchIndex["mayda_codec"] = {"doc":"The purpose of this crate is to relegate the functions generated by the\n`encode!`, `decode!`, `encode_simd!`, `decode_simd!` and `encode_util!`\nsyntax extensions of `mayda_macros` to a separate compilation unit. More\nextensive documentation is provided in the `mayda_macros` crate.","items":[[5,"encode_delta_u8","mayda_codec","",null,null],[5,"encode_zz_shift_u8","","",null,null],[5,"encode_delta_u16","","",null,null],[5,"encode_zz_shift_u16","","",null,null],[5,"encode_delta_u32","","",null,null],[5,"encode_zz_shift_u32","","",null,null],[5,"encode_delta_u64","","",null,null],[5,"encode_zz_shift_u64","","",null,null],[17,"ENCODE_U8","","",null,null],[17,"DECODE_U8","","",null,null],[17,"ENCODE_SIMD_U8","","",null,null],[17,"DECODE_SIMD_U8","","",null,null],[17,"ENCODE_U16","","",null,null],[17,"DECODE_U16","","",null,null],[17,"ENCODE_SIMD_U16","","",null,null],[17,"DECODE_SIMD_U16","","",null,null],[17,"ENCODE_U32","","",null,null],[17,"DECODE_U32","","",null,null],[17,"ENCODE_SIMD_U32","","",null,null],[17,"DECODE_SIMD_U32","","",null,null],[17,"ENCODE_U64","","",null,null],[17,"DECODE_U64","","",null,null],[17,"ENCODE_SIMD_U64","","",null,null],[17,"DECODE_SIMD_U64","","",null,null]],"paths":[]};
searchIndex["simd"] = {"doc":"`simd` offers a basic interface to the SIMD functionality of CPUs.","items":[[3,"bool8i","simd","Boolean type for 8-bit integers.",null,null],[3,"bool16i","","Boolean type for 16-bit integers.",null,null],[3,"bool32i","","Boolean type for 32-bit integers.",null,null],[3,"bool32f","","Boolean type for 32-bit floats.",null,null],[3,"u32x4","","A SIMD vector of 4 `u32`s.",null,null],[3,"i32x4","","A SIMD vector of 4 `i32`s.",null,null],[3,"f32x4","","A SIMD vector of 4 `f32`s.",null,null],[3,"bool32ix4","","A SIMD boolean vector for length-4 vectors of 32-bit integers.",null,null],[3,"bool32fx4","","A SIMD boolean vector for length-4 vectors of 32-bit floats.",null,null],[3,"u16x8","","A SIMD vector of 8 `u16`s.",null,null],[3,"i16x8","","A SIMD vector of 8 `i16`s.",null,null],[3,"bool16ix8","","A SIMD boolean vector for length-8 vectors of 16-bit integers.",null,null],[3,"u8x16","","A SIMD vector of 16 `u8`s.",null,null],[3,"i8x16","","A SIMD vector of 16 `i8`s.",null,null],[3,"bool8ix16","","A SIMD boolean vector for length-16 vectors of 8-bit integers.",null,null],[11,"new","","Create a new instance.",0,{"inputs":[{"name":"u32"},{"name":"u32"},{"name":"u32"},{"name":"u32"}],"output":{"name":"u32x4"}}],[11,"splat","","Create a new instance where every lane has value `x`.",0,{"inputs":[{"name":"u32"}],"output":{"name":"u32x4"}}],[11,"eq","","Compare for equality.",0,null],[11,"ne","","Compare for equality.",0,null],[11,"lt","","Compare for equality.",0,null],[11,"le","","Compare for equality.",0,null],[11,"gt","","Compare for equality.",0,null],[11,"ge","","Compare for equality.",0,null],[11,"extract","","Extract the value of the `idx`th lane of `self`.",0,null],[11,"replace","","Return a new vector where the `idx`th lane is replaced\nby `elem`.",0,null],[11,"load","","Load a new value from the `idx`th position of `array`.",0,null],[11,"store","","Store the elements of `self` to `array`, starting at\nthe `idx`th position.",0,null],[11,"new","","Create a new instance.",1,{"inputs":[{"name":"i32"},{"name":"i32"},{"name":"i32"},{"name":"i32"}],"output":{"name":"i32x4"}}],[11,"splat","","Create a new instance where every lane has value `x`.",1,{"inputs":[{"name":"i32"}],"output":{"name":"i32x4"}}],[11,"eq","","Compare for equality.",1,null],[11,"ne","","Compare for equality.",1,null],[11,"lt","","Compare for equality.",1,null],[11,"le","","Compare for equality.",1,null],[11,"gt","","Compare for equality.",1,null],[11,"ge","","Compare for equality.",1,null],[11,"extract","","Extract the value of the `idx`th lane of `self`.",1,null],[11,"replace","","Return a new vector where the `idx`th lane is replaced\nby `elem`.",1,null],[11,"load","","Load a new value from the `idx`th position of `array`.",1,null],[11,"store","","Store the elements of `self` to `array`, starting at\nthe `idx`th position.",1,null],[11,"new","","Create a new instance.",2,{"inputs":[{"name":"f32"},{"name":"f32"},{"name":"f32"},{"name":"f32"}],"output":{"name":"f32x4"}}],[11,"splat","","Create a new instance where every lane has value `x`.",2,{"inputs":[{"name":"f32"}],"output":{"name":"f32x4"}}],[11,"eq","","Compare for equality.",2,null],[11,"ne","","Compare for equality.",2,null],[11,"lt","","Compare for equality.",2,null],[11,"le","","Compare for equality.",2,null],[11,"gt","","Compare for equality.",2,null],[11,"ge","","Compare for equality.",2,null],[11,"extract","","Extract the value of the `idx`th lane of `self`.",2,null],[11,"replace","","Return a new vector where the `idx`th lane is replaced\nby `elem`.",2,null],[11,"load","","Load a new value from the `idx`th position of `array`.",2,null],[11,"store","","Store the elements of `self` to `array`, starting at\nthe `idx`th position.",2,null],[11,"new","","Create a new instance.",3,{"inputs":[{"name":"u16"},{"name":"u16"},{"name":"u16"},{"name":"u16"},{"name":"u16"},{"name":"u16"},{"name":"u16"},{"name":"u16"}],"output":{"name":"u16x8"}}],[11,"splat","","Create a new instance where every lane has value `x`.",3,{"inputs":[{"name":"u16"}],"output":{"name":"u16x8"}}],[11,"eq","","Compare for equality.",3,null],[11,"ne","","Compare for equality.",3,null],[11,"lt","","Compare for equality.",3,null],[11,"le","","Compare for equality.",3,null],[11,"gt","","Compare for equality.",3,null],[11,"ge","","Compare for equality.",3,null],[11,"extract","","Extract the value of the `idx`th lane of `self`.",3,null],[11,"replace","","Return a new vector where the `idx`th lane is replaced\nby `elem`.",3,null],[11,"load","","Load a new value from the `idx`th position of `array`.",3,null],[11,"store","","Store the elements of `self` to `array`, starting at\nthe `idx`th position.",3,null],[11,"new","","Create a new instance.",4,{"inputs":[{"name":"i16"},{"name":"i16"},{"name":"i16"},{"name":"i16"},{"name":"i16"},{"name":"i16"},{"name":"i16"},{"name":"i16"}],"output":{"name":"i16x8"}}],[11,"splat","","Create a new instance where every lane has value `x`.",4,{"inputs":[{"name":"i16"}],"output":{"name":"i16x8"}}],[11,"eq","","Compare for equality.",4,null],[11,"ne","","Compare for equality.",4,null],[11,"lt","","Compare for equality.",4,null],[11,"le","","Compare for equality.",4,null],[11,"gt","","Compare for equality.",4,null],[11,"ge","","Compare for equality.",4,null],[11,"extract","","Extract the value of the `idx`th lane of `self`.",4,null],[11,"replace","","Return a new vector where the `idx`th lane is replaced\nby `elem`.",4,null],[11,"load","","Load a new value from the `idx`th position of `array`.",4,null],[11,"store","","Store the elements of `self` to `array`, starting at\nthe `idx`th position.",4,null],[11,"new","","Create a new instance.",5,{"inputs":[{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"}],"output":{"name":"u8x16"}}],[11,"splat","","Create a new instance where every lane has value `x`.",5,{"inputs":[{"name":"u8"}],"output":{"name":"u8x16"}}],[11,"eq","","Compare for equality.",5,null],[11,"ne","","Compare for equality.",5,null],[11,"lt","","Compare for equality.",5,null],[11,"le","","Compare for equality.",5,null],[11,"gt","","Compare for equality.",5,null],[11,"ge","","Compare for equality.",5,null],[11,"extract","","Extract the value of the `idx`th lane of `self`.",5,null],[11,"replace","","Return a new vector where the `idx`th lane is replaced\nby `elem`.",5,null],[11,"load","","Load a new value from the `idx`th position of `array`.",5,null],[11,"store","","Store the elements of `self` to `array`, starting at\nthe `idx`th position.",5,null],[11,"new","","Create a new instance.",6,{"inputs":[{"name":"i8"},{"name":"i8"},{"name":"i8"},{"name":"i8"},{"name":"i8"},{"name":"i8"},{"name":"i8"},{"name":"i8"},{"name":"i8"},{"name":"i8"},{"name":"i8"},{"name":"i8"},{"name":"i8"},{"name":"i8"},{"name":"i8"},{"name":"i8"}],"output":{"name":"i8x16"}}],[11,"splat","","Create a new instance where every lane has value `x`.",6,{"inputs":[{"name":"i8"}],"output":{"name":"i8x16"}}],[11,"eq","","Compare for equality.",6,null],[11,"ne","","Compare for equality.",6,null],[11,"lt","","Compare for equality.",6,null],[11,"le","","Compare for equality.",6,null],[11,"gt","","Compare for equality.",6,null],[11,"ge","","Compare for equality.",6,null],[11,"extract","","Extract the value of the `idx`th lane of `self`.",6,null],[11,"replace","","Return a new vector where the `idx`th lane is replaced\nby `elem`.",6,null],[11,"load","","Load a new value from the `idx`th position of `array`.",6,null],[11,"store","","Store the elements of `self` to `array`, starting at\nthe `idx`th position.",6,null],[11,"to_repr","","Convert to integer representation.",7,null],[11,"from_repr","","Convert from integer representation.",7,{"inputs":[{"name":"i32x4"}],"output":{"name":"self"}}],[11,"new","","Create a new instance.",7,{"inputs":[{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"}],"output":{"name":"bool32ix4"}}],[11,"splat","","Create a new instance where every lane has value `x`.",7,{"inputs":[{"name":"bool"}],"output":{"name":"bool32ix4"}}],[11,"extract","","Extract the value of the `idx`th lane of `self`.",7,null],[11,"replace","","Return a new vector where the `idx`th lane is replaced\nby `elem`.",7,null],[11,"select","","Select between elements of `then` and `else_`, based on\nthe corresponding element of `self`.",7,null],[11,"all","","Check if every element of `self` is true.",7,null],[11,"any","","Check if any element of `self` is true.",7,null],[11,"to_f","","Convert `self` to a boolean vector for interacting with floating point vectors.",7,null],[11,"not","","",7,null],[11,"to_repr","","Convert to integer representation.",8,null],[11,"from_repr","","Convert from integer representation.",8,{"inputs":[{"name":"i32x4"}],"output":{"name":"self"}}],[11,"new","","Create a new instance.",8,{"inputs":[{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"}],"output":{"name":"bool32fx4"}}],[11,"splat","","Create a new instance where every lane has value `x`.",8,{"inputs":[{"name":"bool"}],"output":{"name":"bool32fx4"}}],[11,"extract","","Extract the value of the `idx`th lane of `self`.",8,null],[11,"replace","","Return a new vector where the `idx`th lane is replaced\nby `elem`.",8,null],[11,"select","","Select between elements of `then` and `else_`, based on\nthe corresponding element of `self`.",8,null],[11,"all","","Check if every element of `self` is true.",8,null],[11,"any","","Check if any element of `self` is true.",8,null],[11,"to_i","","Convert `self` to a boolean vector for interacting with integer vectors.",8,null],[11,"not","","",8,null],[11,"to_repr","","Convert to integer representation.",9,null],[11,"from_repr","","Convert from integer representation.",9,{"inputs":[{"name":"i16x8"}],"output":{"name":"self"}}],[11,"new","","Create a new instance.",9,{"inputs":[{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"}],"output":{"name":"bool16ix8"}}],[11,"splat","","Create a new instance where every lane has value `x`.",9,{"inputs":[{"name":"bool"}],"output":{"name":"bool16ix8"}}],[11,"extract","","Extract the value of the `idx`th lane of `self`.",9,null],[11,"replace","","Return a new vector where the `idx`th lane is replaced\nby `elem`.",9,null],[11,"select","","Select between elements of `then` and `else_`, based on\nthe corresponding element of `self`.",9,null],[11,"all","","Check if every element of `self` is true.",9,null],[11,"any","","Check if any element of `self` is true.",9,null],[11,"not","","",9,null],[11,"to_repr","","Convert to integer representation.",10,null],[11,"from_repr","","Convert from integer representation.",10,{"inputs":[{"name":"i8x16"}],"output":{"name":"self"}}],[11,"new","","Create a new instance.",10,{"inputs":[{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"bool"}],"output":{"name":"bool8ix16"}}],[11,"splat","","Create a new instance where every lane has value `x`.",10,{"inputs":[{"name":"bool"}],"output":{"name":"bool8ix16"}}],[11,"extract","","Extract the value of the `idx`th lane of `self`.",10,null],[11,"replace","","Return a new vector where the `idx`th lane is replaced\nby `elem`.",10,null],[11,"select","","Select between elements of `then` and `else_`, based on\nthe corresponding element of `self`.",10,null],[11,"all","","Check if every element of `self` is true.",10,null],[11,"any","","Check if any element of `self` is true.",10,null],[11,"not","","",10,null],[11,"to_i32","","Convert each lane to a signed integer.",0,null],[11,"to_f32","","Convert each lane to a 32-bit float.",0,null],[11,"to_u32","","Convert each lane to an unsigned integer.",1,null],[11,"to_f32","","Convert each lane to a 32-bit float.",1,null],[11,"sqrt","","Compute the square root of each lane.",2,null],[11,"approx_rsqrt","","Compute an approximation to the reciprocal of the square root\nof `self`, that is, `f32::splat(1.0) / self.sqrt()`.",2,null],[11,"approx_reciprocal","","Compute an approximation to the reciprocal of `self`, that is,\n`f32::splat(1.0) / self`.",2,null],[11,"max","","Compute the lane-wise maximum of `self` and `other`.",2,null],[11,"min","","Compute the lane-wise minimum of `self` and `other`.",2,null],[11,"to_i32","","Convert each lane to a signed integer.",2,null],[11,"to_u32","","Convert each lane to an unsigned integer.",2,null],[11,"to_u16","","Convert each lane to an unsigned integer.",4,null],[11,"to_i16","","Convert each lane to a signed integer.",3,null],[11,"to_u8","","Convert each lane to an unsigned integer.",6,null],[11,"to_i8","","Convert each lane to a signed integer.",5,null],[11,"neg","","",1,null],[11,"neg","","",4,null],[11,"neg","","",6,null],[11,"neg","","",2,null],[11,"not","","",1,null],[11,"not","","",4,null],[11,"not","","",6,null],[11,"not","","",0,null],[11,"not","","",3,null],[11,"not","","",5,null],[11,"add","","",6,null],[11,"add","","",5,null],[11,"add","","",4,null],[11,"add","","",3,null],[11,"add","","",1,null],[11,"add","","",0,null],[11,"add","","",2,null],[11,"sub","","",6,null],[11,"sub","","",5,null],[11,"sub","","",4,null],[11,"sub","","",3,null],[11,"sub","","",1,null],[11,"sub","","",0,null],[11,"sub","","",2,null],[11,"mul","","",6,null],[11,"mul","","",5,null],[11,"mul","","",4,null],[11,"mul","","",3,null],[11,"mul","","",1,null],[11,"mul","","",0,null],[11,"mul","","",2,null],[11,"div","","",2,null],[11,"bitand","","",6,null],[11,"bitand","","",5,null],[11,"bitand","","",4,null],[11,"bitand","","",3,null],[11,"bitand","","",1,null],[11,"bitand","","",0,null],[11,"bitand","","",10,null],[11,"bitand","","",9,null],[11,"bitand","","",7,null],[11,"bitand","","",8,null],[11,"bitor","","",6,null],[11,"bitor","","",5,null],[11,"bitor","","",4,null],[11,"bitor","","",3,null],[11,"bitor","","",1,null],[11,"bitor","","",0,null],[11,"bitor","","",10,null],[11,"bitor","","",9,null],[11,"bitor","","",7,null],[11,"bitor","","",8,null],[11,"bitxor","","",6,null],[11,"bitxor","","",5,null],[11,"bitxor","","",4,null],[11,"bitxor","","",3,null],[11,"bitxor","","",1,null],[11,"bitxor","","",0,null],[11,"bitxor","","",10,null],[11,"bitxor","","",9,null],[11,"bitxor","","",7,null],[11,"bitxor","","",8,null],[11,"shl","","",6,null],[11,"shr","","",6,null],[11,"shl","","",6,null],[11,"shr","","",6,null],[11,"shl","","",6,null],[11,"shr","","",6,null],[11,"shl","","",6,null],[11,"shr","","",6,null],[11,"shl","","",6,null],[11,"shr","","",6,null],[11,"shl","","",6,null],[11,"shr","","",6,null],[11,"shl","","",6,null],[11,"shr","","",6,null],[11,"shl","","",6,null],[11,"shr","","",6,null],[11,"shl","","",6,null],[11,"shr","","",6,null],[11,"shl","","",6,null],[11,"shr","","",6,null],[11,"shl","","",5,null],[11,"shr","","",5,null],[11,"shl","","",5,null],[11,"shr","","",5,null],[11,"shl","","",5,null],[11,"shr","","",5,null],[11,"shl","","",5,null],[11,"shr","","",5,null],[11,"shl","","",5,null],[11,"shr","","",5,null],[11,"shl","","",5,null],[11,"shr","","",5,null],[11,"shl","","",5,null],[11,"shr","","",5,null],[11,"shl","","",5,null],[11,"shr","","",5,null],[11,"shl","","",5,null],[11,"shr","","",5,null],[11,"shl","","",5,null],[11,"shr","","",5,null],[11,"shl","","",4,null],[11,"shr","","",4,null],[11,"shl","","",4,null],[11,"shr","","",4,null],[11,"shl","","",4,null],[11,"shr","","",4,null],[11,"shl","","",4,null],[11,"shr","","",4,null],[11,"shl","","",4,null],[11,"shr","","",4,null],[11,"shl","","",4,null],[11,"shr","","",4,null],[11,"shl","","",4,null],[11,"shr","","",4,null],[11,"shl","","",4,null],[11,"shr","","",4,null],[11,"shl","","",4,null],[11,"shr","","",4,null],[11,"shl","","",4,null],[11,"shr","","",4,null],[11,"shl","","",3,null],[11,"shr","","",3,null],[11,"shl","","",3,null],[11,"shr","","",3,null],[11,"shl","","",3,null],[11,"shr","","",3,null],[11,"shl","","",3,null],[11,"shr","","",3,null],[11,"shl","","",3,null],[11,"shr","","",3,null],[11,"shl","","",3,null],[11,"shr","","",3,null],[11,"shl","","",3,null],[11,"shr","","",3,null],[11,"shl","","",3,null],[11,"shr","","",3,null],[11,"shl","","",3,null],[11,"shr","","",3,null],[11,"shl","","",3,null],[11,"shr","","",3,null],[11,"shl","","",1,null],[11,"shr","","",1,null],[11,"shl","","",1,null],[11,"shr","","",1,null],[11,"shl","","",1,null],[11,"shr","","",1,null],[11,"shl","","",1,null],[11,"shr","","",1,null],[11,"shl","","",1,null],[11,"shr","","",1,null],[11,"shl","","",1,null],[11,"shr","","",1,null],[11,"shl","","",1,null],[11,"shr","","",1,null],[11,"shl","","",1,null],[11,"shr","","",1,null],[11,"shl","","",1,null],[11,"shr","","",1,null],[11,"shl","","",1,null],[11,"shr","","",1,null],[11,"shl","","",0,null],[11,"shr","","",0,null],[11,"shl","","",0,null],[11,"shr","","",0,null],[11,"shl","","",0,null],[11,"shr","","",0,null],[11,"shl","","",0,null],[11,"shr","","",0,null],[11,"shl","","",0,null],[11,"shr","","",0,null],[11,"shl","","",0,null],[11,"shr","","",0,null],[11,"shl","","",0,null],[11,"shr","","",0,null],[11,"shl","","",0,null],[11,"shr","","",0,null],[11,"shl","","",0,null],[11,"shr","","",0,null],[11,"shl","","",0,null],[11,"shr","","",0,null],[0,"x86","","Features specific to x86 and x86-64 CPUs.",null,null],[0,"sse2","simd::x86","",null,null],[3,"f64x2","simd::x86::sse2","A SIMD vector of 2 `f64`s.",null,null],[3,"i64x2","","A SIMD vector of 2 `i64`s.",null,null],[3,"u64x2","","A SIMD vector of 2 `u64`s.",null,null],[3,"bool64ix2","","A SIMD boolean vector for length-2 vectors of 64-bit integers.",null,null],[3,"bool64fx2","","A SIMD boolean vector for length-2 vectors of 64-bit floats.",null,null],[8,"Sse2F32x4","","",null,null],[10,"to_f64","","",11,null],[10,"move_mask","","",11,null],[8,"Sse2Bool32fx4","","",null,null],[10,"move_mask","","",12,null],[8,"Sse2F64x2","","",null,null],[10,"move_mask","","",13,null],[10,"sqrt","","",13,null],[10,"max","","",13,null],[10,"min","","",13,null],[8,"Sse2Bool64fx2","","",null,null],[10,"move_mask","","",14,null],[8,"Sse2U64x2","","",null,null],[8,"Sse2I64x2","","",null,null],[8,"Sse2Bool64ix2","","",null,null],[8,"Sse2U32x4","","",null,null],[10,"low_mul","","",15,null],[8,"Sse2I32x4","","",null,null],[10,"packs","","",16,null],[8,"Sse2Bool32ix4","","",null,null],[8,"Sse2U16x8","","",null,null],[10,"adds","","",17,null],[10,"subs","","",17,null],[10,"avg","","",17,null],[10,"mulhi","","",17,null],[8,"Sse2I16x8","","",null,null],[10,"adds","","",18,null],[10,"subs","","",18,null],[10,"madd","","",18,null],[10,"max","","",18,null],[10,"min","","",18,null],[10,"mulhi","","",18,null],[10,"packs","","",18,null],[10,"packus","","",18,null],[8,"Sse2Bool16ix8","","",null,null],[8,"Sse2U8x16","","",null,null],[10,"move_mask","","",19,null],[10,"adds","","",19,null],[10,"subs","","",19,null],[10,"avg","","",19,null],[10,"max","","",19,null],[10,"min","","",19,null],[10,"sad","","",19,null],[8,"Sse2I8x16","","",null,null],[10,"move_mask","","",20,null],[10,"adds","","",20,null],[10,"subs","","",20,null],[8,"Sse2Bool8ix16","","",null,null],[10,"move_mask","","",21,null],[11,"to_f64","simd","",2,null],[11,"move_mask","","",2,null],[11,"move_mask","","",8,null],[11,"move_mask","simd::x86::sse2","",22,null],[11,"sqrt","","",22,null],[11,"max","","",22,null],[11,"min","","",22,null],[11,"move_mask","","",23,null],[11,"low_mul","simd","",0,null],[11,"packs","","",1,null],[11,"adds","","",3,null],[11,"subs","","",3,null],[11,"avg","","",3,null],[11,"mulhi","","",3,null],[11,"adds","","",4,null],[11,"subs","","",4,null],[11,"madd","","",4,null],[11,"max","","",4,null],[11,"min","","",4,null],[11,"mulhi","","",4,null],[11,"packs","","",4,null],[11,"packus","","",4,null],[11,"move_mask","","",5,null],[11,"adds","","",5,null],[11,"subs","","",5,null],[11,"avg","","",5,null],[11,"max","","",5,null],[11,"min","","",5,null],[11,"sad","","",5,null],[11,"move_mask","","",6,null],[11,"adds","","",6,null],[11,"subs","","",6,null],[11,"move_mask","","",10,null],[8,"Simd","","Types that are SIMD vectors.",null,null],[16,"Bool","","The corresponding boolean vector type.",24,null],[16,"Elem","","The element that this vector stores.",24,null],[11,"cmp","","",25,null],[11,"partial_cmp","","",25,null],[11,"lt","","",25,null],[11,"le","","",25,null],[11,"gt","","",25,null],[11,"ge","","",25,null],[11,"eq","","",25,null],[11,"ne","","",25,null],[11,"clone","","",25,null],[11,"fmt","","",25,null],[11,"cmp","","",26,null],[11,"partial_cmp","","",26,null],[11,"lt","","",26,null],[11,"le","","",26,null],[11,"gt","","",26,null],[11,"ge","","",26,null],[11,"eq","","",26,null],[11,"ne","","",26,null],[11,"clone","","",26,null],[11,"fmt","","",26,null],[11,"cmp","","",27,null],[11,"partial_cmp","","",27,null],[11,"lt","","",27,null],[11,"le","","",27,null],[11,"gt","","",27,null],[11,"ge","","",27,null],[11,"eq","","",27,null],[11,"ne","","",27,null],[11,"clone","","",27,null],[11,"fmt","","",27,null],[11,"cmp","","",28,null],[11,"partial_cmp","","",28,null],[11,"lt","","",28,null],[11,"le","","",28,null],[11,"gt","","",28,null],[11,"ge","","",28,null],[11,"eq","","",28,null],[11,"ne","","",28,null],[11,"clone","","",28,null],[11,"fmt","","",28,null],[11,"from","","",25,{"inputs":[{"name":"bool"}],"output":{"name":"bool8i"}}],[11,"from","","",26,{"inputs":[{"name":"bool"}],"output":{"name":"bool16i"}}],[11,"from","","",27,{"inputs":[{"name":"bool"}],"output":{"name":"bool32i"}}],[11,"from","","",28,{"inputs":[{"name":"bool"}],"output":{"name":"bool32f"}}],[11,"fmt","","",0,null],[11,"fmt","","",1,null],[11,"fmt","","",2,null],[11,"fmt","","",7,null],[11,"fmt","","",8,null],[11,"fmt","","",3,null],[11,"fmt","","",4,null],[11,"fmt","","",9,null],[11,"fmt","","",5,null],[11,"fmt","","",6,null],[11,"fmt","","",10,null],[11,"clone","","",6,null],[11,"clone","","",5,null],[11,"clone","","",10,null],[11,"clone","","",4,null],[11,"clone","","",3,null],[11,"clone","","",9,null],[11,"clone","","",1,null],[11,"clone","","",0,null],[11,"clone","","",7,null],[11,"clone","","",2,null],[11,"clone","","",8,null],[11,"fmt","simd::x86::sse2","",29,null],[11,"fmt","","",30,null],[11,"fmt","","",22,null],[11,"fmt","","",31,null],[11,"fmt","","",23,null],[11,"clone","","",30,null],[11,"clone","","",29,null],[11,"clone","","",31,null],[11,"clone","","",22,null],[11,"clone","","",23,null],[11,"new","","Create a new instance.",29,{"inputs":[{"name":"u64"},{"name":"u64"}],"output":{"name":"u64x2"}}],[11,"splat","","Create a new instance where every lane has value `x`.",29,{"inputs":[{"name":"u64"}],"output":{"name":"u64x2"}}],[11,"eq","","Compare for equality.",29,null],[11,"ne","","Compare for equality.",29,null],[11,"lt","","Compare for equality.",29,null],[11,"le","","Compare for equality.",29,null],[11,"gt","","Compare for equality.",29,null],[11,"ge","","Compare for equality.",29,null],[11,"extract","","Extract the value of the `idx`th lane of `self`.",29,null],[11,"replace","","Return a new vector where the `idx`th lane is replaced\nby `elem`.",29,null],[11,"load","","Load a new value from the `idx`th position of `array`.",29,null],[11,"store","","Store the elements of `self` to `array`, starting at\nthe `idx`th position.",29,null],[11,"new","","Create a new instance.",30,{"inputs":[{"name":"i64"},{"name":"i64"}],"output":{"name":"i64x2"}}],[11,"splat","","Create a new instance where every lane has value `x`.",30,{"inputs":[{"name":"i64"}],"output":{"name":"i64x2"}}],[11,"eq","","Compare for equality.",30,null],[11,"ne","","Compare for equality.",30,null],[11,"lt","","Compare for equality.",30,null],[11,"le","","Compare for equality.",30,null],[11,"gt","","Compare for equality.",30,null],[11,"ge","","Compare for equality.",30,null],[11,"extract","","Extract the value of the `idx`th lane of `self`.",30,null],[11,"replace","","Return a new vector where the `idx`th lane is replaced\nby `elem`.",30,null],[11,"load","","Load a new value from the `idx`th position of `array`.",30,null],[11,"store","","Store the elements of `self` to `array`, starting at\nthe `idx`th position.",30,null],[11,"new","","Create a new instance.",22,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64x2"}}],[11,"splat","","Create a new instance where every lane has value `x`.",22,{"inputs":[{"name":"f64"}],"output":{"name":"f64x2"}}],[11,"eq","","Compare for equality.",22,null],[11,"ne","","Compare for equality.",22,null],[11,"lt","","Compare for equality.",22,null],[11,"le","","Compare for equality.",22,null],[11,"gt","","Compare for equality.",22,null],[11,"ge","","Compare for equality.",22,null],[11,"extract","","Extract the value of the `idx`th lane of `self`.",22,null],[11,"replace","","Return a new vector where the `idx`th lane is replaced\nby `elem`.",22,null],[11,"load","","Load a new value from the `idx`th position of `array`.",22,null],[11,"store","","Store the elements of `self` to `array`, starting at\nthe `idx`th position.",22,null],[11,"to_repr","","Convert to integer representation.",31,null],[11,"from_repr","","Convert from integer representation.",31,{"inputs":[{"name":"i64x2"}],"output":{"name":"self"}}],[11,"new","","Create a new instance.",31,{"inputs":[{"name":"bool"},{"name":"bool"}],"output":{"name":"bool64ix2"}}],[11,"splat","","Create a new instance where every lane has value `x`.",31,{"inputs":[{"name":"bool"}],"output":{"name":"bool64ix2"}}],[11,"extract","","Extract the value of the `idx`th lane of `self`.",31,null],[11,"replace","","Return a new vector where the `idx`th lane is replaced\nby `elem`.",31,null],[11,"select","","Select between elements of `then` and `else_`, based on\nthe corresponding element of `self`.",31,null],[11,"all","","Check if every element of `self` is true.",31,null],[11,"any","","Check if any element of `self` is true.",31,null],[11,"to_f","","Convert `self` to a boolean vector for interacting with floating point vectors.",31,null],[11,"not","","",31,null],[11,"to_repr","","Convert to integer representation.",23,null],[11,"from_repr","","Convert from integer representation.",23,{"inputs":[{"name":"i64x2"}],"output":{"name":"self"}}],[11,"new","","Create a new instance.",23,{"inputs":[{"name":"bool"},{"name":"bool"}],"output":{"name":"bool64fx2"}}],[11,"splat","","Create a new instance where every lane has value `x`.",23,{"inputs":[{"name":"bool"}],"output":{"name":"bool64fx2"}}],[11,"extract","","Extract the value of the `idx`th lane of `self`.",23,null],[11,"replace","","Return a new vector where the `idx`th lane is replaced\nby `elem`.",23,null],[11,"select","","Select between elements of `then` and `else_`, based on\nthe corresponding element of `self`.",23,null],[11,"all","","Check if every element of `self` is true.",23,null],[11,"any","","Check if any element of `self` is true.",23,null],[11,"to_i","","Convert `self` to a boolean vector for interacting with integer vectors.",23,null],[11,"not","","",23,null],[11,"to_i64","","Convert each lane to a signed integer.",29,null],[11,"to_f64","","Convert each lane to a 64-bit float.",29,null],[11,"to_u64","","Convert each lane to an unsigned integer.",30,null],[11,"to_f64","","Convert each lane to a 64-bit float.",30,null],[11,"to_i64","","Convert each lane to a signed integer.",22,null],[11,"to_u64","","Convert each lane to an unsigned integer.",22,null],[11,"to_f32","","Convert each lane to a 32-bit float.",22,null],[11,"neg","","",30,null],[11,"neg","","",22,null],[11,"not","","",30,null],[11,"not","","",29,null],[11,"add","","",30,null],[11,"add","","",29,null],[11,"add","","",22,null],[11,"sub","","",30,null],[11,"sub","","",29,null],[11,"sub","","",22,null],[11,"mul","","",30,null],[11,"mul","","",29,null],[11,"mul","","",22,null],[11,"div","","",22,null],[11,"bitand","","",30,null],[11,"bitand","","",29,null],[11,"bitand","","",31,null],[11,"bitand","","",23,null],[11,"bitor","","",30,null],[11,"bitor","","",29,null],[11,"bitor","","",31,null],[11,"bitor","","",23,null],[11,"bitxor","","",30,null],[11,"bitxor","","",29,null],[11,"bitxor","","",31,null],[11,"bitxor","","",23,null],[11,"shl","","",30,null],[11,"shr","","",30,null],[11,"shl","","",30,null],[11,"shr","","",30,null],[11,"shl","","",30,null],[11,"shr","","",30,null],[11,"shl","","",30,null],[11,"shr","","",30,null],[11,"shl","","",30,null],[11,"shr","","",30,null],[11,"shl","","",30,null],[11,"shr","","",30,null],[11,"shl","","",30,null],[11,"shr","","",30,null],[11,"shl","","",30,null],[11,"shr","","",30,null],[11,"shl","","",30,null],[11,"shr","","",30,null],[11,"shl","","",30,null],[11,"shr","","",30,null],[11,"shl","","",29,null],[11,"shr","","",29,null],[11,"shl","","",29,null],[11,"shr","","",29,null],[11,"shl","","",29,null],[11,"shr","","",29,null],[11,"shl","","",29,null],[11,"shr","","",29,null],[11,"shl","","",29,null],[11,"shr","","",29,null],[11,"shl","","",29,null],[11,"shr","","",29,null],[11,"shl","","",29,null],[11,"shr","","",29,null],[11,"shl","","",29,null],[11,"shr","","",29,null],[11,"shl","","",29,null],[11,"shr","","",29,null],[11,"shl","","",29,null],[11,"shr","","",29,null]],"paths":[[3,"u32x4"],[3,"i32x4"],[3,"f32x4"],[3,"u16x8"],[3,"i16x8"],[3,"u8x16"],[3,"i8x16"],[3,"bool32ix4"],[3,"bool32fx4"],[3,"bool16ix8"],[3,"bool8ix16"],[8,"Sse2F32x4"],[8,"Sse2Bool32fx4"],[8,"Sse2F64x2"],[8,"Sse2Bool64fx2"],[8,"Sse2U32x4"],[8,"Sse2I32x4"],[8,"Sse2U16x8"],[8,"Sse2I16x8"],[8,"Sse2U8x16"],[8,"Sse2I8x16"],[8,"Sse2Bool8ix16"],[3,"f64x2"],[3,"bool64fx2"],[8,"Simd"],[3,"bool8i"],[3,"bool16i"],[3,"bool32i"],[3,"bool32f"],[3,"u64x2"],[3,"i64x2"],[3,"bool64ix2"]]};
searchIndex["mayda_macros"] = {"doc":"Compiler plugins to generate basic encoding and decoding functions. The\nfunctions generated by the `encode!` and `decode!` syntax extensions follow\nthe convention `encode_T_a_b`. The functions generated by the\n`encode_simd!` and `decode_simd!` syntax extensions follow the convention\n`encode_simd_T_a`. The functions generated by the `encode_util!` syntax\nextention follow the conventions `encode_delta_T` and `encode_zz_shift_T`.\n`T` is one of the unsigned integer types, `a` is the number of bits per\ninteger, and `b` is the number of integers encoded.","items":[[5,"plugin_registrar","mayda_macros","Registers the encode and decode syntax expansions.",null,{"inputs":[{"name":"registry"}],"output":null}]],"paths":[]};
initSearch(searchIndex);
